package generator

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"os"
	"path/filepath"

	"github.com/ninedraft/enum2go/pkg/astx"
	"github.com/ninedraft/enum2go/pkg/static"
)

// Config describes some
type Config struct {
	Dir        string
	TargetFile string
	FileIO     FIO
}

// Run generates enum definitions using config data and specs in user code.
func Run(cfg *Config) error {
	var fset = token.NewFileSet()
	var fileIO = cfg.FileIO
	if fileIO == nil {
		fileIO = nativeFileIO{}
	}
	var pkg, files, errPkg = fileIO.ParsePkg(fset, cfg.Dir)
	if errPkg != nil {
		return fmt.Errorf("parsing dir %q: %w", cfg.Dir, errPkg)
	}
	var bind, errBind = bindSpecs(fset, pkg, files)
	if errBind != nil {
		return errBind
	}
	var results = make([]*ast.File, 0, len(bind.specs))
	for _, spec := range bind.specs {
		var cast, _ = static.Cast.AST()
		spec.Pour(cfg, cast)
		results = append(results, cast)
	}
	var dst = &ast.File{
		Name: ast.NewIdent(pkg),
	}
	astx.MergeFiles(dst, results)
	var generated = bytes.NewBufferString("// generated by enum2go. DO NOT EDIT.\n\n")
	if err := format.Node(generated, fset, dst); err != nil {
		return err
	}
	var target = filepath.Join(cfg.Dir, cfg.TargetFile)
	return fileIO.WriteFile(target, generated)
}

// FIO describes a generic file input/output system.
type FIO interface {
	ParsePkg(fset *token.FileSet, dir string) (pkgName string, _ []*ast.File, _ error)
	WriteFile(name string, data io.Reader) error
}

type nativeFileIO struct{}

func (nfio nativeFileIO) ParsePkg(fset *token.FileSet, dir string) (pkgName string, _ []*ast.File, _ error) {
	var pkgs, errParse = parser.ParseDir(fset, dir, nfio.fileFilter, parser.AllErrors)
	if errParse != nil {
		return "", nil, errParse
	}
	var pkg, errSelect = astx.SelectPkg(pkgs)
	if errSelect != nil {
		return "", nil, errSelect
	}
	return pkg.Name, astx.PkgFiles(pkg), nil
}

func (nfio nativeFileIO) WriteFile(name string, data io.Reader) (err error) {
	const flags = os.O_WRONLY | os.O_CREATE | os.O_TRUNC
	const mod os.FileMode = 0600
	var file, errOpen = os.OpenFile(name, flags, mod)
	if errOpen != nil {
		return errOpen
	}
	defer func() { err = file.Close() }()
	var _, errWrite = io.Copy(file, data)
	if errWrite != nil {
		return fmt.Errorf("writing file content: %w", errWrite)
	}
	return nil
}

func (nativeFileIO) fileFilter(os.FileInfo) bool { return true }
